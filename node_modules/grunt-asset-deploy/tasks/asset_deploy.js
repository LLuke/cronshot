/*jslint node:true, nomen:true, stupid:true, vars:true */

'use strict';

var http = require('http'),
    mime = require('mime'),
    path = require('path'),
    fs = require('fs'),
    mobstor = require('mobstor'),
    yca,
    DEFAULT_CONCURRENCY = 100;

http.globalAgent.maxSockets = 10000;

try {
    yca = require('yca');
} catch (e) { }

function checkVal(val) {
    return (typeof val === "undefined" || val === '');
}

module.exports = function (grunt) {

    grunt.registerMultiTask('asset_deploy', 'Deploy assets to MObStor.', function () {
        grunt.log.writeln("[start] " + grunt.task.current.name);

        // Merge task-specific and/or target-specific options with these defaults.
        var options = this.options();

        if (checkVal(options.src)) { grunt.fatal('Please provide the location of the files to deploy.'); }
        if (checkVal(options.host)) { grunt.fatal('MObStor hostname cannot be empty. Example: media.zenfs.com'); }
        if (checkVal(options.path)) { grunt.fatal('Please define the path to your MObStor directory.'); }
        if (checkVal(options.yca)) { grunt.fatal('A proper YCA certificate must be passed in.'); }

        var done = this.async(),
            host = options.host,
            maxAge = options.maxAge || 60 * 60 * 24 * 365 * 17, // Expire in 17 years or 536112000
            proxy = {
                host: 'yca-proxy.corp.yahoo.com',
                port: 3128
            },
            headers = options.headers || {},
            concurrency = options.concurrency || DEFAULT_CONCURRENCY,
            dryrun = grunt.option('dryrun') || false,
            certificate,
            q;

        // get YCA certificate
        if (yca) {
            certificate = (new yca.YCA()).get_cert(options.yca);
        } else {
            grunt.log.warn('[grunt-asset-deploy] YCA not found. It is required to push assets to MObStor.');
        }

        // create a queue to reduce throughput to mobstor
        q = grunt.util.async.queue(function (item, callback) {
            var url,
                filePath = path.resolve(options.src, item),
                ext = path.extname(item),
                config = {
                    host: host,
                    maxAge: maxAge,
                    proxy: proxy,
                    headers: grunt.util._.clone(headers),
                    certificate: certificate
                };

            // ensure we only deploy files
            if (!grunt.file.isFile(filePath)) {
                callback();
                return;
            }

            // create the final url that will be uploaded to mobstor
            url = 'http://' + options.host + options.path + item;

            // add content type header for request
            config.headers["Content-Type"] = mime.lookup(filePath);

            // if it's a font file, add CORS header
            switch (ext) {
            case '.eot':
            case '.woff':
            case '.ttf':
            case '.svg':
                config.headers["x-ysws-cors-allowed-origin"] = '*';
                break;
            }

            // create mobstor instance
            var client = mobstor.createClient(config);

            try {
                client.checkFile(url, function mobstorCheckFileCb(err, resp) {
                    if (resp && resp.statusCode === 200 && !options.force) {
                        console.log('Asset already exists ' + url);
                        callback();
                    } else {
                        // handle encoding based on file extension
                        var content;

                        if (ext === '.js' || ext === '.css') {
                            content = fs.readFileSync(filePath, 'utf-8');
                            if (ext === '.js') {
                                content = content + ';';
                            }
                        } else {
                            content = fs.createReadStream(filePath);
                        }

                        if (!dryrun) {
                            client.storeFile(url, content, function mobstorStoreFileCb(err) {
                                // skip 409 conflict issues since the asset was uploaded correctly
                                if (err && err.code !== 409) {
                                    console.log('URI Failed: ' + url);
                                    callback(err);
                                } else {
                                    console.log('Successfully deployed ' + url);
                                    callback();
                                }
                            });
                        } else {
                            grunt.log.warn('Dryrun: deploying of ' + url);
                            callback();
                        }
                    }
                });
            } catch (e) {
                console.log(e);
                callback(e);
            }
        }, concurrency);

        // called after queue is done
        q.drain = function() {
            grunt.log.writeln("[end] " + grunt.task.current.name);
            done();
        };

        // find the files to deploy
        grunt.file.glob('**/*.*', { cwd: options.src, sync: true }, function (err, files) {
            files.forEach(function (item) {
                q.push(item, function (err) {
                    if (err) {
                        grunt.log.writeln("[end] " + grunt.task.current.name);
                        grunt.fatal(err);
                    }
                });
            });
        });
    });

};
