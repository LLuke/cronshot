/*
 * Copyright (c) 2011 Yahoo! Inc. All rights reserved.
 */
/*jslint node: true, continue: true, forin: true, plusplus: true, sloppy: true */
var http = require('http'),
    https = require('https'),
    url = require('url'),
    path = require('path'),
    util = require('util');

/**
 * @package ynodejs_mobstor
 */

/**
 * @module mobstor
 */
var DEFAULT_REQUEST_TIMEOUT = 10000;
var DEFAULT_MAX_REDIRECT = 10;

// merge host name and path
var mergeUri = function (self, path) {
    var normalized_path = path.trim().toLowerCase(),
        url,
        info;

    if (normalized_path.indexOf('http://') === 0 || normalized_path.indexOf('https://') === 0) {
        return path;
    } else {
        url = {
            host : self.options.host,
            port : self.options.port,
            protocol : self.options.protocol
        };

        info = require('url').format(url);
        if (self.options.port !== 80) {
            info += ":" + self.options.port;
        }

        info = require('url').resolve(info, path);

        return info;
    }
};

// Validate URL using regular expression
var validateUrl = function (url) {
    var RegExp = /(http|ftp|https):\/\/[\w\-_]+(\.[\w\-_]+)+([\w\-\.,@?\^=%&amp;:\/~\\+#]*[\w\-\@?\^=%&amp;\/~\+#])?/;
    return RegExp.test(url);
};

// make an asynchrous HTTP/HTTPS request
var request = function (method, path, body, config, callback) {
    var self = this,
        urlparsed,
        options,
        handle,
        req,
        stat;

    config = config || {};
    config.port = config.port || 80;
    config.timeout = config.timeout || DEFAULT_REQUEST_TIMEOUT;

    // parse url
    urlparsed = url.parse(path);
    if (!urlparsed) {
        callback(new Error('invalid path'));
        return;
    }

    options = {
        host : urlparsed.hostname,
        path : urlparsed.pathname,
        port : urlparsed.port || config.port,
        method : method,
        maxRedirect : config.maxRedirect,
        headers : config.headers || {}
    };

    // append query string to the request path
    if (urlparsed.query) {
        options.path = options.path + "?" + urlparsed.query;
    }

    if (urlparsed.protocol) {
        options.protocol = urlparsed.protocol.trim();
    } else {
        options.protocol = 'http:';
    }

    options.port = options.port || 80;

    // set default headers
    options.headers.Accept = '*/*';
    options.headers['User-Agent'] = 'ynodejs_mobstor 1.0 API';
    options.headers.Host = options.host;
    if (options.port !== 80) {
        options.headers.Host += ":" + options.port;
    }

    if (body instanceof require("stream").Stream) {
        if (body.path) {
            stat = require('fs').statSync(body.path);
            if (stat && stat.size) {
                options.headers['Content-Length'] = stat.size;
            }
        }
    } else if (body instanceof require("buffer").Buffer) {
        options.headers['Content-Length'] = body.length;
    } else if (typeof body === 'string') {
        options.headers['Content-Length'] = Buffer.byteLength(body, 'utf-8');
    } else if (!body) {
        options.headers['Content-Length'] = 0;
    } else {
        try {
            body = JSON.stringify(body);
            options.headers['Content-Length'] = Buffer.byteLength(body, 'utf-8');
        } catch (error) {
            callback(error);
        }
    }

    // handle proxy information
    if (config.proxy && config.proxy.host && config.proxy.port) {
        options.host = config.proxy.host;
        options.port = config.proxy.port;
        options.path = urlparsed.href;
    }

    if (options.protocol.indexOf(":") === -1) {
        options.protocol = options.protocol + ":";
    }

    handle = (urlparsed.protocol === 'https:') ? https : http;
    req = handle.request(options);
    // set timeout
    req.setTimeout(config.timeout, function () {
        process.nextTick(function () {
            callback(new Error("Request timed out"));
            req.abort();
        });
    });

    req.on('response', function (res) {
        var error;
        if ((res.statusCode >= 300 && res.statusCode < 400)) {
            // Follow the redirect
            if (res.headers && res.headers.location) {
                if (options.maxRedirect > 0) {
                    config.maxRedirect = options.maxRedirect - 1;
                    request(method, url.resolve(path, res.headers.location), body, config, callback);
                } else {
                    callback(new Error(
                        'Reached the Maximum Redirection Limit'
                    ));
                    return;
                }
            } else {
                callback(new Error(
                    'MObStor returned 3xx status code, but location header is missing'
                ));
                return;
            }
        } else if ((res.statusCode === 200 || res.statusCode === 201)) {
            callback(null, res);
        } else {
            // Some other Sherpa error happend.
            error = new Error('Error response from MObStor, error code: ' + res.statusCode + ', for more details, see http://devel.corp.yahoo.com/mobstor/guide/response_codes.html');
            error.code = res.statusCode;
            callback(error, res);
        }

        res.resume();
    });

    req.on('error', function (exception) {
        callback(exception);
    });

    if (body instanceof require("stream").Stream) {
        // body is stream
        body.pipe(req);
        body.on('error', function (err) {
            callback(err);
        });
        body.on('end', function () {
            req.end();
        });
    } else {
        if (body) {
            req.write(body);
        }
        req.end();
    }
};

// clone main configuration obect to the new install
function clone(obj) {
    var copy = null;

    // Handle the 3 simple types, and null or undefined
    if (null === obj || typeof obj !== "object") {
        return obj;
    }

    // Handle Object
    if (obj instanceof Object) {
        copy = {};

        Object.keys(obj).forEach(function (attr) {
            if (obj.hasOwnProperty(attr)) {
                copy[attr] = clone(obj[attr]);
            }
        });

        return copy;
    }

    throw new Error("Unable to copy obj! Its type isn't supported.");
}
/**
 * JavaScript wrapper of MObStor client.
 *
 * <pre>
 * Configure connection information
 *
 * var config = {
 *     // mandatory
 *     host : &quot;your.mobstordomain.name&quot;,
 *     // optional, defult 80
 *     port : 80,
 *     certificate : (new yca.YCA()).get_cert(&quot;your.application.id&quot;),
 *     // proxy information is optional for access from corp network to product network
 *     proxy : {                            
 *         host : &quot;yca-proxy.corp.yahoo.com&quot;,
 *         port : 3128
 *     }
 * };
 *
 * //Create a client instance
 * var client = mobstor.createClient(config);
 *
 * // Call API
 * try {
 *      client.storeFile(&quot;/test.txt&quot;, content1, function(error, data) {
 *          if(error!=null) {
 *              // handle error object
 *              // error.code: http status code (can be undefined if the error is not caused by HTTP error)
 *              // error.message: error message
 *          }
 *          else {
 *              // data is JavaScript Stream object
 *          }
 *      });
 * }
 * catch(error) {
 *      // error handling..
 * }
 * </pre>
 *
 * @param option
 *            {Object} Configuration
 *
 * @class Client
 *
 * @constructor
 *
 */
function Client(option) {
    if (option === undefined || option === null || typeof option !== 'object') {
        throw new Error('Invalid Parameter');
    }

    if (!option.host) {
        throw new Error('MObStor host is not set in the configuration object');
    }

    this.options = option || {};
    this.options.headers = this.options.headers || {};

    this.options.port = option.port || 80;
    this.options.protocol = option.protocol || 'http';

    if (typeof option.maxRedirect !== 'number') {
        this.options.maxRedirect = DEFAULT_MAX_REDIRECT;
    } else {
        this.options.maxRedirect = option.maxRedirect;
    }

    // certificate
    if (option.certificate) {
        this.options.headers["Yahoo-App-Auth"] = this.options.certificate;
    }

    // cache control header
    if (this.options.maxAge) {
        this.options.headers["Cache-Control"] = "max-age=" + this.options.maxAge;
    }

    // protocol version
    this.options.headers["x-ysws-version"] = "1.0";
}

/**
 * Creates a new resource or updates the value of an existing resource. If the
 * resource does not already exist, then MObStor creates the resource and
 * returns a 201 Created response. If the resource already exists, then MObStor
 * overwrites the object's current contents and header values.
 *
 * The maximum URL length for PUT requests is 1024 bytes.
 *
 * Please read http://devel.yahoo.com/mobstor/guide/put.html for more
 * information.
 *
 * @method storeFile
 *
 * @param path
 *            {String} absolute path of full uri of the destination
 * @param data
 *            {String/Object} String or readable stream to be stored. If data
 *            type of this parameter is object, then JSON.stringify string will
 *            be stored.
 *
 * @param callback
 *            {Function(error, data)}
 *
 * @throws {Error}
 */
Client.prototype.storeFile = function (path, body, callback) {
    // validate path format
    var fullPath, config;

    if (!callback || typeof callback !== 'function') {
        throw new Error('callback function is missing.');
    }
    fullPath = mergeUri(this, path);

    if (validateUrl(fullPath) === false) {
        callback(new Error('invalid path'));
        return;
    }

    if (path.substr(-1) === '/') {
        callback(new Error('use createFolder instead'));
        return;
    }

    config = clone(this.options);

    request('PUT', fullPath, body, config, callback);
};

/**
 * Retrieves the contents of an object. Retrieving on a folder is allowed, but
 * returns an unspecified response body.
 *
 * You can also use checkFile to retrieve information about a folder.
 *
 * Please read http://devel.yahoo.com/mobstor/guide/get.html for more
 * information.
 *
 * @method retrieveFile
 *
 * @param path
 *            {String} Resource to be read. Data read from MObStor will be store
 *            in the body parameter
 *
 * @param callback
 *            {Function(error, data)} Callback function
 *
 * @throws {Error}
 *
 */
Client.prototype.retrieveFile = function (path, callback) {
    var fullPath, config;
    if (typeof callback !== 'function') {
        throw new Error('callback function is missing.');
    }

    // validate path format
    fullPath = mergeUri(this, path);
    if (validateUrl(fullPath) === false) {
        callback(new Error('invalid path'));
        return;
    }

    if (path.substr(-1) === '/') {
        callback(new Error('cannot retrieve folder'));
        return;
    }

    config = clone(this.options);
    request('GET', fullPath, null, config, callback);
};

/**
 * checkFile method returns only the HTTP headers for a object or folder. This
 * method provides a quick way to check whether an object has changed since it
 * was last fetched, or to simply verify that a particular folder exists.
 *
 * checkFile uses HTTP HEAD method internally. The HEAD method is preferred over
 * the retrieveFile method for checking a resource's existence or fetching its
 * metadata, since it does not download the object's contents.
 *
 * Please read http://devel.yahoo.com/mobstor/guide/head.html for more
 * information.
 *
 * @method checkFile
 *
 * @param path
 *            {String} Object path
 *
 * @param callback
 *            {Function(error, data)} Callback function
 *
 * @throws {Error}
 *
 */
Client.prototype.checkFile = function (path, callback) {
    var fullPath, config;
    if (typeof callback !== 'function') {
        throw new Error('callback function is missing.');
    }

    // validate path format
    fullPath = mergeUri(this, path);
    if (validateUrl(fullPath) === false) {
        callback(new Error('invalid path'));
        return;
    }

    if (path.substr(-1) === '/') {
        callback(new Error('use checkFolder instead'));
        return;
    }

    config = clone(this.options);
    request('HEAD', fullPath, null, config, callback);
};

/**
 * Deletes the objects.
 *
 * Implementation of DELETE API
 * (http://devel.yahoo.com/mobstor/guide/methods.html#delete)
 *
 * @method deleteFile
 *
 * @param path
 *            {String} Resource to be removed
 *
 * @param callback
 *            {Function(error, data)} Callback function
 *
 * @throws {Error}
 *
 */
Client.prototype.deleteFile = function (path, callback) {
    var fullPath, config;
    if (typeof callback !== 'function') {
        throw new Error('callback function is missing.');
    }

    // validate path format
    fullPath = mergeUri(this, path);
    if (validateUrl(fullPath) === false) {
        callback(new Error('invalid path'));
        return;
    }

    if (path.substr(-1) === '/') {
        callback(new Error('cannot remove folder'));
        return;
    }

    config = clone(this.options);

    config.headers = this.options.headers || {};

    request('DELETE', fullPath, null, config, callback);
};

/**
 * Create a new folder. Folder names must end in a forward slash. If the slash
 * is missing, the method throws Error
 *
 * Remember: you can only create a new resource if the resource's parent folder
 * already exists.
 *
 * @param path
 *            {String} Resource to be removed
 *
 * @param callback
 *            {Function(error, data)} Callback function
 *
 * @throws {Error}
 *
 */
Client.prototype.createFolder = function (path, callback) {
    var fullPath, config;
    if (!callback || typeof callback !== 'function') {
        throw new Error('callback function is missing.');
    }

    if (!path) {
        throw new Error('path is missing');
    }

    // validate path format
    fullPath = mergeUri(this, path);
    if (validateUrl(fullPath) === false) {
        callback(new Error('invalid path format'));
        return;
    }

    if (fullPath.substr(-1) !== '/') {
        callback(new Error('path must ends with \'/\'.'));
        return;
    }

    config = clone(this.options);

    config.headers = this.options.headers || {};
    config.headers["Content-Length"] = "0";

    request('PUT', fullPath, null, config, callback);
};

/**
 * Check availability of folder body of the resource.
 *
 * Implementation of HEAD API [http://devel.yahoo.com/mobstor/guide/head.html]
 *
 * @method checkFolder
 * @param path
 *            {String} Directory to be created
 * @param callback
 *            {Function} Callback function
 */
Client.prototype.checkFolder = function (path, callback) {
    var fullPath, config;
    if (typeof callback !== 'function') {
        throw new Error('callback function is missing.');
    }

    if (!path) {
        throw new Error('path is missing');
    }

    // validate path format
    fullPath = mergeUri(this, path);
    if (validateUrl(fullPath) === false) {
        throw new Error('invalid path format');
    }

    if (fullPath.substr(-1) !== '/') {
        throw new Error('path must ends with \'/\'.');
    }

    config = clone(this.options);
    request('HEAD', fullPath, null, config, callback);
};

/**
 * Get signed/tokenized url
 *
 * A signed URL is a read-only URL that is valid for only a short period of time -
 * i.e., a URL with an expiration date. It provides time-limited access to an
 * otherwise private MObStor object.
 *
 * In contrast to the auto-expires feature, a signed URL does not affect the
 * lifetime of the actual stored object. Signed URLs can be created for expiring
 * as well as auto-expiring content.
 *
 * Please read http://devel.yahoo.com/mobstor/guide/ch03s05.html#SignedURLs for
 * more information.
 *
 * @method getSignedUrl
 *
 * @param url
 *            {String} URL to be signed/tokenized.
 *
 * @param expiry
 *            {Number} Expiration time in seconds from request time
 * @param callback
 *            {Function(error, data)} Callback function
 *
 */

Client.prototype.getSignedUrl = function (path, expiry, callback) {
    // internal application path
    var applicationPath = '/mbst/admin/v1/tokenized_url',
        fullPath,
        config,
        expiryVal;

    if (typeof callback !== 'function') {
        throw new Error('callback function is missing.');
    }

    // validate url format
    fullPath = mergeUri(this, path);
    if (validateUrl(fullPath) === false) {
        callback(new Error('invalid path format'));
        return;
    }

    applicationPath = mergeUri(this, applicationPath);

    // validate expiry time number format
    expiryVal = parseInt(expiry, 10);
    if (isNaN(expiryVal) || expiryVal <= 0) {
        callback(new Error('invalid expiry'));
        return;
    }

    // initiate POST method
    config = clone(this.options);

    config.headers = this.options.headers || {};
    // compose timeout headers
    config.headers["x-ysws-token-expiry-time"] = expiryVal;

    // source url for signed url generation is in the request body
    request('POST', applicationPath, fullPath, config, callback);
};

/**
 * Export factory method
 *
 * @param config
 *            {Object} Configuration object
 */
exports.createClient = function (config) {
    return new Client(config);
};
