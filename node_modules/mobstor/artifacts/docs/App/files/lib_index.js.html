<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>lib/index.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title=""></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/Client.html">Client</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/mobstor.html">mobstor</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: lib/index.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/*
 * Copyright (c) 2011 Yahoo! Inc. All rights reserved.
 */
/*jslint node: true, continue: true, forin: true, plusplus: true, sloppy: true */
var http = require(&#x27;http&#x27;),
    https = require(&#x27;https&#x27;),
    url = require(&#x27;url&#x27;),
    path = require(&#x27;path&#x27;),
    util = require(&#x27;util&#x27;);

/**
 * @package ynodejs_mobstor
 */

/**
 * @module mobstor
 */
var DEFAULT_REQUEST_TIMEOUT = 10000;
var DEFAULT_MAX_REDIRECT = 10;

// merge host name and path
var mergeUri = function (self, path) {
    var normalized_path = path.trim().toLowerCase(),
        url,
        info;

    if (normalized_path.indexOf(&#x27;http://&#x27;) === 0 || normalized_path.indexOf(&#x27;https://&#x27;) === 0) {
        return path;
    } else {
        url = {
            host : self.options.host,
            port : self.options.port,
            protocol : self.options.protocol
        };

        info = require(&#x27;url&#x27;).format(url);
        if (self.options.port !== 80) {
            info += &quot;:&quot; + self.options.port;
        }

        info = require(&#x27;url&#x27;).resolve(info, path);

        return info;
    }
};

// Validate URL using regular expression
var validateUrl = function (url) {
    var RegExp = /(http|ftp|https):\/\/[\w\-_]+(\.[\w\-_]+)+([\w\-\.,@?\^=%&amp;amp;:\/~\\+#]*[\w\-\@?\^=%&amp;amp;\/~\+#])?/;
    return RegExp.test(url);
};

// make an asynchrous HTTP/HTTPS request
var request = function (method, path, body, config, callback) {
    var self = this,
        urlparsed,
        options,
        handle,
        req,
        stat;

    config = config || {};
    config.port = config.port || 80;
    config.timeout = config.timeout || DEFAULT_REQUEST_TIMEOUT;

    // parse url
    urlparsed = url.parse(path);
    if (!urlparsed) {
        callback(new Error(&#x27;invalid path&#x27;));
        return;
    }

    options = {
        host : urlparsed.hostname,
        path : urlparsed.pathname,
        port : urlparsed.port || config.port,
        method : method,
        maxRedirect : config.maxRedirect,
        headers : config.headers || {}
    };

    // append query string to the request path
    if (urlparsed.query) {
        options.path = options.path + &quot;?&quot; + urlparsed.query;
    }

    if (urlparsed.protocol) {
        options.protocol = urlparsed.protocol.trim();
    } else {
        options.protocol = &#x27;http:&#x27;;
    }

    options.port = options.port || 80;

    // set default headers
    options.headers.Accept = &#x27;*/*&#x27;;
    options.headers[&#x27;User-Agent&#x27;] = &#x27;ynodejs_mobstor 1.0 API&#x27;;
    options.headers.Host = options.host;
    if (options.port !== 80) {
        options.headers.Host += &quot;:&quot; + options.port;
    }

    if (body instanceof require(&quot;stream&quot;).Stream) {
        if (body.path) {
            stat = require(&#x27;fs&#x27;).statSync(body.path);
            if (stat &amp;&amp; stat.size) {
                options.headers[&#x27;Content-Length&#x27;] = stat.size;
            }
        }
    } else if (body instanceof require(&quot;buffer&quot;).Buffer) {
        options.headers[&#x27;Content-Length&#x27;] = body.length;
    } else if (typeof body === &#x27;string&#x27;) {
        options.headers[&#x27;Content-Length&#x27;] = Buffer.byteLength(body, &#x27;utf-8&#x27;);
    } else if (!body) {
        options.headers[&#x27;Content-Length&#x27;] = 0;
    } else {
        try {
            body = JSON.stringify(body);
            options.headers[&#x27;Content-Length&#x27;] = Buffer.byteLength(body, &#x27;utf-8&#x27;);
        } catch (error) {
            callback(error);
        }
    }

    // handle proxy information
    if (config.proxy &amp;&amp; config.proxy.host &amp;&amp; config.proxy.port) {
        options.host = config.proxy.host;
        options.port = config.proxy.port;
        options.path = urlparsed.href;
    }

    if (options.protocol.indexOf(&quot;:&quot;) === -1) {
        options.protocol = options.protocol + &quot;:&quot;;
    }

    handle = (urlparsed.protocol === &#x27;https:&#x27;) ? https : http;
    req = handle.request(options);
    // set timeout
    req.setTimeout(config.timeout, function () {
        process.nextTick(function () {
            callback(new Error(&quot;Request timed out&quot;));
            req.abort();
        });
    });

    req.on(&#x27;response&#x27;, function (res) {
        var error;
        if ((res.statusCode &gt;= 300 &amp;&amp; res.statusCode &lt; 400)) {
            // Follow the redirect
            if (res.headers &amp;&amp; res.headers.location) {
                if (options.maxRedirect &gt; 0) {
                    config.maxRedirect = options.maxRedirect - 1;
                    request(method, url.resolve(path, res.headers.location), body, config, callback);
                } else {
                    callback(new Error(
                        &#x27;Reached the Maximum Redirection Limit&#x27;
                    ));
                    return;
                }
            } else {
                callback(new Error(
                    &#x27;MObStor returned 3xx status code, but location header is missing&#x27;
                ));
                return;
            }
        } else if ((res.statusCode === 200 || res.statusCode === 201)) {
            callback(null, res);
        } else {
            // Some other Sherpa error happend.
            error = new Error(&#x27;Error response from MObStor, error code: &#x27; + res.statusCode + &#x27;, for more details, see http://devel.corp.yahoo.com/mobstor/guide/response_codes.html&#x27;);
            error.code = res.statusCode;
            callback(error, res);
        }

        res.resume();
    });

    req.on(&#x27;error&#x27;, function (exception) {
        callback(exception);
    });

    if (body instanceof require(&quot;stream&quot;).Stream) {
        // body is stream
        body.pipe(req);
        body.on(&#x27;error&#x27;, function (err) {
            callback(err);
        });
        body.on(&#x27;end&#x27;, function () {
            req.end();
        });
    } else {
        if (body) {
            req.write(body);
        }
        req.end();
    }
};

// clone main configuration obect to the new install
function clone(obj) {
    var copy = null;

    // Handle the 3 simple types, and null or undefined
    if (null === obj || typeof obj !== &quot;object&quot;) {
        return obj;
    }

    // Handle Object
    if (obj instanceof Object) {
        copy = {};

        Object.keys(obj).forEach(function (attr) {
            if (obj.hasOwnProperty(attr)) {
                copy[attr] = clone(obj[attr]);
            }
        });

        return copy;
    }

    throw new Error(&quot;Unable to copy obj! Its type isn&#x27;t supported.&quot;);
}
/**
 * JavaScript wrapper of MObStor client.
 *
 * &lt;pre&gt;
 * Configure connection information
 *
 * var config = {
 *     // mandatory
 *     host : &amp;quot;your.mobstordomain.name&amp;quot;,
 *     // optional, defult 80
 *     port : 80,
 *     certificate : (new yca.YCA()).get_cert(&amp;quot;your.application.id&amp;quot;),
 *     // proxy information is optional for access from corp network to product network
 *     proxy : {                            
 *         host : &amp;quot;yca-proxy.corp.yahoo.com&amp;quot;,
 *         port : 3128
 *     }
 * };
 *
 * //Create a client instance
 * var client = mobstor.createClient(config);
 *
 * // Call API
 * try {
 *      client.storeFile(&amp;quot;/test.txt&amp;quot;, content1, function(error, data) {
 *          if(error!=null) {
 *              // handle error object
 *              // error.code: http status code (can be undefined if the error is not caused by HTTP error)
 *              // error.message: error message
 *          }
 *          else {
 *              // data is JavaScript Stream object
 *          }
 *      });
 * }
 * catch(error) {
 *      // error handling..
 * }
 * &lt;/pre&gt;
 *
 * @param option
 *            {Object} Configuration
 *
 * @class Client
 *
 * @constructor
 *
 */
function Client(option) {
    if (option === undefined || option === null || typeof option !== &#x27;object&#x27;) {
        throw new Error(&#x27;Invalid Parameter&#x27;);
    }

    if (!option.host) {
        throw new Error(&#x27;MObStor host is not set in the configuration object&#x27;);
    }

    this.options = option || {};
    this.options.headers = this.options.headers || {};

    this.options.port = option.port || 80;
    this.options.protocol = option.protocol || &#x27;http&#x27;;

    if (typeof option.maxRedirect !== &#x27;number&#x27;) {
        this.options.maxRedirect = DEFAULT_MAX_REDIRECT;
    } else {
        this.options.maxRedirect = option.maxRedirect;
    }

    // certificate
    if (option.certificate) {
        this.options.headers[&quot;Yahoo-App-Auth&quot;] = this.options.certificate;
    }

    // cache control header
    if (this.options.maxAge) {
        this.options.headers[&quot;Cache-Control&quot;] = &quot;max-age=&quot; + this.options.maxAge;
    }

    // protocol version
    this.options.headers[&quot;x-ysws-version&quot;] = &quot;1.0&quot;;
}

/**
 * Creates a new resource or updates the value of an existing resource. If the
 * resource does not already exist, then MObStor creates the resource and
 * returns a 201 Created response. If the resource already exists, then MObStor
 * overwrites the object&#x27;s current contents and header values.
 *
 * The maximum URL length for PUT requests is 1024 bytes.
 *
 * Please read http://devel.yahoo.com/mobstor/guide/put.html for more
 * information.
 *
 * @method storeFile
 *
 * @param path
 *            {String} absolute path of full uri of the destination
 * @param data
 *            {String/Object} String or readable stream to be stored. If data
 *            type of this parameter is object, then JSON.stringify string will
 *            be stored.
 *
 * @param callback
 *            {Function(error, data)}
 *
 * @throws {Error}
 */
Client.prototype.storeFile = function (path, body, callback) {
    // validate path format
    var fullPath, config;

    if (!callback || typeof callback !== &#x27;function&#x27;) {
        throw new Error(&#x27;callback function is missing.&#x27;);
    }
    fullPath = mergeUri(this, path);

    if (validateUrl(fullPath) === false) {
        callback(new Error(&#x27;invalid path&#x27;));
        return;
    }

    if (path.substr(-1) === &#x27;/&#x27;) {
        callback(new Error(&#x27;use createFolder instead&#x27;));
        return;
    }

    config = clone(this.options);

    request(&#x27;PUT&#x27;, fullPath, body, config, callback);
};

/**
 * Retrieves the contents of an object. Retrieving on a folder is allowed, but
 * returns an unspecified response body.
 *
 * You can also use checkFile to retrieve information about a folder.
 *
 * Please read http://devel.yahoo.com/mobstor/guide/get.html for more
 * information.
 *
 * @method retrieveFile
 *
 * @param path
 *            {String} Resource to be read. Data read from MObStor will be store
 *            in the body parameter
 *
 * @param callback
 *            {Function(error, data)} Callback function
 *
 * @throws {Error}
 *
 */
Client.prototype.retrieveFile = function (path, callback) {
    var fullPath, config;
    if (typeof callback !== &#x27;function&#x27;) {
        throw new Error(&#x27;callback function is missing.&#x27;);
    }

    // validate path format
    fullPath = mergeUri(this, path);
    if (validateUrl(fullPath) === false) {
        callback(new Error(&#x27;invalid path&#x27;));
        return;
    }

    if (path.substr(-1) === &#x27;/&#x27;) {
        callback(new Error(&#x27;cannot retrieve folder&#x27;));
        return;
    }

    config = clone(this.options);
    request(&#x27;GET&#x27;, fullPath, null, config, callback);
};

/**
 * checkFile method returns only the HTTP headers for a object or folder. This
 * method provides a quick way to check whether an object has changed since it
 * was last fetched, or to simply verify that a particular folder exists.
 *
 * checkFile uses HTTP HEAD method internally. The HEAD method is preferred over
 * the retrieveFile method for checking a resource&#x27;s existence or fetching its
 * metadata, since it does not download the object&#x27;s contents.
 *
 * Please read http://devel.yahoo.com/mobstor/guide/head.html for more
 * information.
 *
 * @method checkFile
 *
 * @param path
 *            {String} Object path
 *
 * @param callback
 *            {Function(error, data)} Callback function
 *
 * @throws {Error}
 *
 */
Client.prototype.checkFile = function (path, callback) {
    var fullPath, config;
    if (typeof callback !== &#x27;function&#x27;) {
        throw new Error(&#x27;callback function is missing.&#x27;);
    }

    // validate path format
    fullPath = mergeUri(this, path);
    if (validateUrl(fullPath) === false) {
        callback(new Error(&#x27;invalid path&#x27;));
        return;
    }

    if (path.substr(-1) === &#x27;/&#x27;) {
        callback(new Error(&#x27;use checkFolder instead&#x27;));
        return;
    }

    config = clone(this.options);
    request(&#x27;HEAD&#x27;, fullPath, null, config, callback);
};

/**
 * Deletes the objects.
 *
 * Implementation of DELETE API
 * (http://devel.yahoo.com/mobstor/guide/methods.html#delete)
 *
 * @method deleteFile
 *
 * @param path
 *            {String} Resource to be removed
 *
 * @param callback
 *            {Function(error, data)} Callback function
 *
 * @throws {Error}
 *
 */
Client.prototype.deleteFile = function (path, callback) {
    var fullPath, config;
    if (typeof callback !== &#x27;function&#x27;) {
        throw new Error(&#x27;callback function is missing.&#x27;);
    }

    // validate path format
    fullPath = mergeUri(this, path);
    if (validateUrl(fullPath) === false) {
        callback(new Error(&#x27;invalid path&#x27;));
        return;
    }

    if (path.substr(-1) === &#x27;/&#x27;) {
        callback(new Error(&#x27;cannot remove folder&#x27;));
        return;
    }

    config = clone(this.options);

    config.headers = this.options.headers || {};

    request(&#x27;DELETE&#x27;, fullPath, null, config, callback);
};

/**
 * Create a new folder. Folder names must end in a forward slash. If the slash
 * is missing, the method throws Error
 *
 * Remember: you can only create a new resource if the resource&#x27;s parent folder
 * already exists.
 *
 * @param path
 *            {String} Resource to be removed
 *
 * @param callback
 *            {Function(error, data)} Callback function
 *
 * @throws {Error}
 *
 */
Client.prototype.createFolder = function (path, callback) {
    var fullPath, config;
    if (!callback || typeof callback !== &#x27;function&#x27;) {
        throw new Error(&#x27;callback function is missing.&#x27;);
    }

    if (!path) {
        throw new Error(&#x27;path is missing&#x27;);
    }

    // validate path format
    fullPath = mergeUri(this, path);
    if (validateUrl(fullPath) === false) {
        callback(new Error(&#x27;invalid path format&#x27;));
        return;
    }

    if (fullPath.substr(-1) !== &#x27;/&#x27;) {
        callback(new Error(&#x27;path must ends with \&#x27;/\&#x27;.&#x27;));
        return;
    }

    config = clone(this.options);

    config.headers = this.options.headers || {};
    config.headers[&quot;Content-Length&quot;] = &quot;0&quot;;

    request(&#x27;PUT&#x27;, fullPath, null, config, callback);
};

/**
 * Check availability of folder body of the resource.
 *
 * Implementation of HEAD API [http://devel.yahoo.com/mobstor/guide/head.html]
 *
 * @method checkFolder
 * @param path
 *            {String} Directory to be created
 * @param callback
 *            {Function} Callback function
 */
Client.prototype.checkFolder = function (path, callback) {
    var fullPath, config;
    if (typeof callback !== &#x27;function&#x27;) {
        throw new Error(&#x27;callback function is missing.&#x27;);
    }

    if (!path) {
        throw new Error(&#x27;path is missing&#x27;);
    }

    // validate path format
    fullPath = mergeUri(this, path);
    if (validateUrl(fullPath) === false) {
        throw new Error(&#x27;invalid path format&#x27;);
    }

    if (fullPath.substr(-1) !== &#x27;/&#x27;) {
        throw new Error(&#x27;path must ends with \&#x27;/\&#x27;.&#x27;);
    }

    config = clone(this.options);
    request(&#x27;HEAD&#x27;, fullPath, null, config, callback);
};

/**
 * Get signed/tokenized url
 *
 * A signed URL is a read-only URL that is valid for only a short period of time -
 * i.e., a URL with an expiration date. It provides time-limited access to an
 * otherwise private MObStor object.
 *
 * In contrast to the auto-expires feature, a signed URL does not affect the
 * lifetime of the actual stored object. Signed URLs can be created for expiring
 * as well as auto-expiring content.
 *
 * Please read http://devel.yahoo.com/mobstor/guide/ch03s05.html#SignedURLs for
 * more information.
 *
 * @method getSignedUrl
 *
 * @param url
 *            {String} URL to be signed/tokenized.
 *
 * @param expiry
 *            {Number} Expiration time in seconds from request time
 * @param callback
 *            {Function(error, data)} Callback function
 *
 */

Client.prototype.getSignedUrl = function (path, expiry, callback) {
    // internal application path
    var applicationPath = &#x27;/mbst/admin/v1/tokenized_url&#x27;,
        fullPath,
        config,
        expiryVal;

    if (typeof callback !== &#x27;function&#x27;) {
        throw new Error(&#x27;callback function is missing.&#x27;);
    }

    // validate url format
    fullPath = mergeUri(this, path);
    if (validateUrl(fullPath) === false) {
        callback(new Error(&#x27;invalid path format&#x27;));
        return;
    }

    applicationPath = mergeUri(this, applicationPath);

    // validate expiry time number format
    expiryVal = parseInt(expiry, 10);
    if (isNaN(expiryVal) || expiryVal &lt;= 0) {
        callback(new Error(&#x27;invalid expiry&#x27;));
        return;
    }

    // initiate POST method
    config = clone(this.options);

    config.headers = this.options.headers || {};
    // compose timeout headers
    config.headers[&quot;x-ysws-token-expiry-time&quot;] = expiryVal;

    // source url for signed url generation is in the request body
    request(&#x27;POST&#x27;, applicationPath, fullPath, config, callback);
};

/**
 * Export factory method
 *
 * @param config
 *            {Object} Configuration object
 */
exports.createClient = function (config) {
    return new Client(config);
};

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
